// ----------------------------------------
//
// Grasshopper harness for debugging reachability related bugs in CIVL encoding.
//
// When copying Boogie code here, make the following replacements:
// Bool -> Bool
// "call" -> ""
// 
// ----------------------------------------

struct Ref {}

type Heap

pure function next(h: Heap) returns (f: Map<Ref, Ref>)
pure function dom(h: Heap) returns (f: Map<Ref, Bool>)

pure function EmptyHeap() returns (h: Heap)
  ensures (forall x: Ref :: !dom(EmptyHeap())[x])

pure function Add(h: Heap, l: Ref, v: Ref) returns (h: Heap)
  ensures (forall h: Heap, l: Ref, v: Ref ::
    dom(Add(h, l, v)) == dom(h)[l:=true] && next(Add(h, l, v)) == next(h)[l := v])

pure function Remove(h: Heap, l: Ref) returns (h: Heap)
  ensures (forall h: Heap, l: Ref ::
    dom(Remove(h, l)) == dom(h)[l:=false] && next(Remove(h, l)) == next(h))

var queue: Heap
var Used: Map<Ref, Bool>

var head: Ref
var tail: Ref

pure function knownF(f: Map<Ref, Ref>) returns (b: Bool) { true }

// function BtwnSet(f: Map<Ref, Ref>, x: Ref, z: Ref) returns (S: <Ref, Bool>)
//   ensures (forall f: [Ref]Ref, x: Ref, y: Ref, z: Ref ::
//     BtwnSet(f, x, z)[y] <==> Btwn(f, x, y, z));
//   ensures (forall f: [Ref]Ref, x: Ref, y: Ref, z: Ref ::
//     Btwn(f, x, y, z) ==> BtwnSet(f, x, z)[y]);

define BtwnSet(f, x, z) { { y: Ref :: Btwn(f, x, y, z) } }

define Singleton(x) { {x} }

define Union(x, y) { x ++ y }

define Equal(x, y) { x == y }


pure predicate Inv(queue: Heap, head: Ref, tail: Ref)
{
  Btwn(next(queue), head, head, null)
    && Btwn(next(queue), head, tail, null)
    // && Equal(BtwnSet(next(queue), head, null),
    //          Union(Singleton(null), dom(queue)))
    // && (forall l: Ref :: {Btwn(next(queue), head, l, null)} known(l) ==>
    //     (Btwn(next(queue), head, l, null) <==> l == null || dom(queue)[l]))
    && tail != null
    // && known(head) && known(tail) && known(null) && knownF(next(queue))
}


procedure test1(x: Ref, t: Ref, tn: Ref, t_Heap: Heap, x_Heap: Heap)
  requires Inv(queue, head, tail);
  requires dom(x_Heap)[x] && next(x_Heap)[x] == null;
  // requires known(x) && known(t) && known(tn) && knownF(next(queue)) && knownF(next(t_Heap));
  requires dom(t_Heap) == dom(x_Heap);
  requires next(t_Heap)[x] == null;
  requires t != null && (Btwn(next(queue), head, t, null)
      || Used[t]);
  requires next(queue)[t] == null ==> t == tail;

  ensures Inv(queue, head, tail);
{
  var g: Bool;
  var out_heap: Heap;
  assume tn == null;

  // g, out_heap := TransferToqueue(t, tn, x, t_Heap);
  if (next(queue)[t] == tn) {
    queue := Add(queue, t, x);
    // queue := Add(queue, x, next(t_Heap)[x]); // TODO this TOs. Why?
    queue := Add(queue, x, null);
    g := true;
  } else {
    g := false;
  }

  if (!g) {
    assume false;
  } else {
  // assert known(head) && known(tail) && known(null) && knownF(next(queue));
  assert Btwn(next(queue), head, head, null);
  assert Btwn(next(queue), head, tail, null);
  // assert Equal(BtwnSet(next(queue), head, null),
  //            Union(Singleton(null), dom(queue)));
  }
}